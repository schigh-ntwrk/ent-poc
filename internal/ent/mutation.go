// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/schigh-ntwrk/entc-poc/internal/ent/appointment"
	"github.com/schigh-ntwrk/entc-poc/internal/ent/clinic"
	"github.com/schigh-ntwrk/entc-poc/internal/ent/customer"
	"github.com/schigh-ntwrk/entc-poc/internal/ent/pet"
	"github.com/schigh-ntwrk/entc-poc/internal/ent/predicate"
	"github.com/schigh-ntwrk/entc-poc/internal/ent/user"
	"github.com/schigh-ntwrk/entc-poc/internal/ent/veterinarian"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAppointment  = "Appointment"
	TypeClinic       = "Clinic"
	TypeCustomer     = "Customer"
	TypePet          = "Pet"
	TypeUser         = "User"
	TypeVeterinarian = "Veterinarian"
)

// AppointmentMutation represents an operation that mutate the Appointments
// nodes in the graph.
type AppointmentMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	removed_at           *time.Time
	start_at             *time.Time
	end_at               *time.Time
	paid_at              *time.Time
	charge               *float64
	addcharge            *float64
	paid                 *bool
	clearedFields        map[string]struct{}
	pets                 *uuid.UUID
	clearedpets          bool
	veterinarians        *uuid.UUID
	clearedveterinarians bool
	done                 bool
	oldValue             func(context.Context) (*Appointment, error)
	predicates           []predicate.Appointment
}

var _ ent.Mutation = (*AppointmentMutation)(nil)

// appointmentOption allows to manage the mutation configuration using functional options.
type appointmentOption func(*AppointmentMutation)

// newAppointmentMutation creates new mutation for $n.Name.
func newAppointmentMutation(c config, op Op, opts ...appointmentOption) *AppointmentMutation {
	m := &AppointmentMutation{
		config:        c,
		op:            op,
		typ:           TypeAppointment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppointmentID sets the id field of the mutation.
func withAppointmentID(id uuid.UUID) appointmentOption {
	return func(m *AppointmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Appointment
		)
		m.oldValue = func(ctx context.Context) (*Appointment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Appointment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppointment sets the old Appointment of the mutation.
func withAppointment(node *Appointment) appointmentOption {
	return func(m *AppointmentMutation) {
		m.oldValue = func(context.Context) (*Appointment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppointmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppointmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Appointment creation.
func (m *AppointmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AppointmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *AppointmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *AppointmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Appointment.
// If the Appointment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppointmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *AppointmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *AppointmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *AppointmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Appointment.
// If the Appointment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppointmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *AppointmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRemovedAt sets the removed_at field.
func (m *AppointmentMutation) SetRemovedAt(t time.Time) {
	m.removed_at = &t
}

// RemovedAt returns the removed_at value in the mutation.
func (m *AppointmentMutation) RemovedAt() (r time.Time, exists bool) {
	v := m.removed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRemovedAt returns the old removed_at value of the Appointment.
// If the Appointment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppointmentMutation) OldRemovedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemovedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemovedAt: %w", err)
	}
	return oldValue.RemovedAt, nil
}

// ClearRemovedAt clears the value of removed_at.
func (m *AppointmentMutation) ClearRemovedAt() {
	m.removed_at = nil
	m.clearedFields[appointment.FieldRemovedAt] = struct{}{}
}

// RemovedAtCleared returns if the field removed_at was cleared in this mutation.
func (m *AppointmentMutation) RemovedAtCleared() bool {
	_, ok := m.clearedFields[appointment.FieldRemovedAt]
	return ok
}

// ResetRemovedAt reset all changes of the "removed_at" field.
func (m *AppointmentMutation) ResetRemovedAt() {
	m.removed_at = nil
	delete(m.clearedFields, appointment.FieldRemovedAt)
}

// SetStartAt sets the start_at field.
func (m *AppointmentMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the start_at value in the mutation.
func (m *AppointmentMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old start_at value of the Appointment.
// If the Appointment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppointmentMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ResetStartAt reset all changes of the "start_at" field.
func (m *AppointmentMutation) ResetStartAt() {
	m.start_at = nil
}

// SetEndAt sets the end_at field.
func (m *AppointmentMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the end_at value in the mutation.
func (m *AppointmentMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old end_at value of the Appointment.
// If the Appointment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppointmentMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ResetEndAt reset all changes of the "end_at" field.
func (m *AppointmentMutation) ResetEndAt() {
	m.end_at = nil
}

// SetPaidAt sets the paid_at field.
func (m *AppointmentMutation) SetPaidAt(t time.Time) {
	m.paid_at = &t
}

// PaidAt returns the paid_at value in the mutation.
func (m *AppointmentMutation) PaidAt() (r time.Time, exists bool) {
	v := m.paid_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidAt returns the old paid_at value of the Appointment.
// If the Appointment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppointmentMutation) OldPaidAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPaidAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPaidAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidAt: %w", err)
	}
	return oldValue.PaidAt, nil
}

// ResetPaidAt reset all changes of the "paid_at" field.
func (m *AppointmentMutation) ResetPaidAt() {
	m.paid_at = nil
}

// SetCharge sets the charge field.
func (m *AppointmentMutation) SetCharge(f float64) {
	m.charge = &f
	m.addcharge = nil
}

// Charge returns the charge value in the mutation.
func (m *AppointmentMutation) Charge() (r float64, exists bool) {
	v := m.charge
	if v == nil {
		return
	}
	return *v, true
}

// OldCharge returns the old charge value of the Appointment.
// If the Appointment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppointmentMutation) OldCharge(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCharge is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCharge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCharge: %w", err)
	}
	return oldValue.Charge, nil
}

// AddCharge adds f to charge.
func (m *AppointmentMutation) AddCharge(f float64) {
	if m.addcharge != nil {
		*m.addcharge += f
	} else {
		m.addcharge = &f
	}
}

// AddedCharge returns the value that was added to the charge field in this mutation.
func (m *AppointmentMutation) AddedCharge() (r float64, exists bool) {
	v := m.addcharge
	if v == nil {
		return
	}
	return *v, true
}

// ResetCharge reset all changes of the "charge" field.
func (m *AppointmentMutation) ResetCharge() {
	m.charge = nil
	m.addcharge = nil
}

// SetPaid sets the paid field.
func (m *AppointmentMutation) SetPaid(b bool) {
	m.paid = &b
}

// Paid returns the paid value in the mutation.
func (m *AppointmentMutation) Paid() (r bool, exists bool) {
	v := m.paid
	if v == nil {
		return
	}
	return *v, true
}

// OldPaid returns the old paid value of the Appointment.
// If the Appointment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AppointmentMutation) OldPaid(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPaid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPaid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaid: %w", err)
	}
	return oldValue.Paid, nil
}

// ResetPaid reset all changes of the "paid" field.
func (m *AppointmentMutation) ResetPaid() {
	m.paid = nil
}

// SetPetsID sets the pets edge to Pet by id.
func (m *AppointmentMutation) SetPetsID(id uuid.UUID) {
	m.pets = &id
}

// ClearPets clears the pets edge to Pet.
func (m *AppointmentMutation) ClearPets() {
	m.clearedpets = true
}

// PetsCleared returns if the edge pets was cleared.
func (m *AppointmentMutation) PetsCleared() bool {
	return m.clearedpets
}

// PetsID returns the pets id in the mutation.
func (m *AppointmentMutation) PetsID() (id uuid.UUID, exists bool) {
	if m.pets != nil {
		return *m.pets, true
	}
	return
}

// PetsIDs returns the pets ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PetsID instead. It exists only for internal usage by the builders.
func (m *AppointmentMutation) PetsIDs() (ids []uuid.UUID) {
	if id := m.pets; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPets reset all changes of the "pets" edge.
func (m *AppointmentMutation) ResetPets() {
	m.pets = nil
	m.clearedpets = false
}

// SetVeterinariansID sets the veterinarians edge to Veterinarian by id.
func (m *AppointmentMutation) SetVeterinariansID(id uuid.UUID) {
	m.veterinarians = &id
}

// ClearVeterinarians clears the veterinarians edge to Veterinarian.
func (m *AppointmentMutation) ClearVeterinarians() {
	m.clearedveterinarians = true
}

// VeterinariansCleared returns if the edge veterinarians was cleared.
func (m *AppointmentMutation) VeterinariansCleared() bool {
	return m.clearedveterinarians
}

// VeterinariansID returns the veterinarians id in the mutation.
func (m *AppointmentMutation) VeterinariansID() (id uuid.UUID, exists bool) {
	if m.veterinarians != nil {
		return *m.veterinarians, true
	}
	return
}

// VeterinariansIDs returns the veterinarians ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// VeterinariansID instead. It exists only for internal usage by the builders.
func (m *AppointmentMutation) VeterinariansIDs() (ids []uuid.UUID) {
	if id := m.veterinarians; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVeterinarians reset all changes of the "veterinarians" edge.
func (m *AppointmentMutation) ResetVeterinarians() {
	m.veterinarians = nil
	m.clearedveterinarians = false
}

// Op returns the operation name.
func (m *AppointmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Appointment).
func (m *AppointmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AppointmentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, appointment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appointment.FieldUpdatedAt)
	}
	if m.removed_at != nil {
		fields = append(fields, appointment.FieldRemovedAt)
	}
	if m.start_at != nil {
		fields = append(fields, appointment.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, appointment.FieldEndAt)
	}
	if m.paid_at != nil {
		fields = append(fields, appointment.FieldPaidAt)
	}
	if m.charge != nil {
		fields = append(fields, appointment.FieldCharge)
	}
	if m.paid != nil {
		fields = append(fields, appointment.FieldPaid)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AppointmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appointment.FieldCreatedAt:
		return m.CreatedAt()
	case appointment.FieldUpdatedAt:
		return m.UpdatedAt()
	case appointment.FieldRemovedAt:
		return m.RemovedAt()
	case appointment.FieldStartAt:
		return m.StartAt()
	case appointment.FieldEndAt:
		return m.EndAt()
	case appointment.FieldPaidAt:
		return m.PaidAt()
	case appointment.FieldCharge:
		return m.Charge()
	case appointment.FieldPaid:
		return m.Paid()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AppointmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appointment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appointment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appointment.FieldRemovedAt:
		return m.OldRemovedAt(ctx)
	case appointment.FieldStartAt:
		return m.OldStartAt(ctx)
	case appointment.FieldEndAt:
		return m.OldEndAt(ctx)
	case appointment.FieldPaidAt:
		return m.OldPaidAt(ctx)
	case appointment.FieldCharge:
		return m.OldCharge(ctx)
	case appointment.FieldPaid:
		return m.OldPaid(ctx)
	}
	return nil, fmt.Errorf("unknown Appointment field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AppointmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appointment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appointment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appointment.FieldRemovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemovedAt(v)
		return nil
	case appointment.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case appointment.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case appointment.FieldPaidAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidAt(v)
		return nil
	case appointment.FieldCharge:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCharge(v)
		return nil
	case appointment.FieldPaid:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaid(v)
		return nil
	}
	return fmt.Errorf("unknown Appointment field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AppointmentMutation) AddedFields() []string {
	var fields []string
	if m.addcharge != nil {
		fields = append(fields, appointment.FieldCharge)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AppointmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appointment.FieldCharge:
		return m.AddedCharge()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AppointmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appointment.FieldCharge:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCharge(v)
		return nil
	}
	return fmt.Errorf("unknown Appointment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AppointmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appointment.FieldRemovedAt) {
		fields = append(fields, appointment.FieldRemovedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AppointmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppointmentMutation) ClearField(name string) error {
	switch name {
	case appointment.FieldRemovedAt:
		m.ClearRemovedAt()
		return nil
	}
	return fmt.Errorf("unknown Appointment nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AppointmentMutation) ResetField(name string) error {
	switch name {
	case appointment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appointment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appointment.FieldRemovedAt:
		m.ResetRemovedAt()
		return nil
	case appointment.FieldStartAt:
		m.ResetStartAt()
		return nil
	case appointment.FieldEndAt:
		m.ResetEndAt()
		return nil
	case appointment.FieldPaidAt:
		m.ResetPaidAt()
		return nil
	case appointment.FieldCharge:
		m.ResetCharge()
		return nil
	case appointment.FieldPaid:
		m.ResetPaid()
		return nil
	}
	return fmt.Errorf("unknown Appointment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AppointmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.pets != nil {
		edges = append(edges, appointment.EdgePets)
	}
	if m.veterinarians != nil {
		edges = append(edges, appointment.EdgeVeterinarians)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AppointmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appointment.EdgePets:
		if id := m.pets; id != nil {
			return []ent.Value{*id}
		}
	case appointment.EdgeVeterinarians:
		if id := m.veterinarians; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AppointmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AppointmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AppointmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpets {
		edges = append(edges, appointment.EdgePets)
	}
	if m.clearedveterinarians {
		edges = append(edges, appointment.EdgeVeterinarians)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AppointmentMutation) EdgeCleared(name string) bool {
	switch name {
	case appointment.EdgePets:
		return m.clearedpets
	case appointment.EdgeVeterinarians:
		return m.clearedveterinarians
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AppointmentMutation) ClearEdge(name string) error {
	switch name {
	case appointment.EdgePets:
		m.ClearPets()
		return nil
	case appointment.EdgeVeterinarians:
		m.ClearVeterinarians()
		return nil
	}
	return fmt.Errorf("unknown Appointment unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AppointmentMutation) ResetEdge(name string) error {
	switch name {
	case appointment.EdgePets:
		m.ResetPets()
		return nil
	case appointment.EdgeVeterinarians:
		m.ResetVeterinarians()
		return nil
	}
	return fmt.Errorf("unknown Appointment edge %s", name)
}

// ClinicMutation represents an operation that mutate the Clinics
// nodes in the graph.
type ClinicMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	removed_at           *time.Time
	name                 *string
	address              *string
	phone                *string
	web_url              *string
	clearedFields        map[string]struct{}
	veterinarians        map[uuid.UUID]struct{}
	removedveterinarians map[uuid.UUID]struct{}
	clearedveterinarians bool
	done                 bool
	oldValue             func(context.Context) (*Clinic, error)
	predicates           []predicate.Clinic
}

var _ ent.Mutation = (*ClinicMutation)(nil)

// clinicOption allows to manage the mutation configuration using functional options.
type clinicOption func(*ClinicMutation)

// newClinicMutation creates new mutation for $n.Name.
func newClinicMutation(c config, op Op, opts ...clinicOption) *ClinicMutation {
	m := &ClinicMutation{
		config:        c,
		op:            op,
		typ:           TypeClinic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClinicID sets the id field of the mutation.
func withClinicID(id uuid.UUID) clinicOption {
	return func(m *ClinicMutation) {
		var (
			err   error
			once  sync.Once
			value *Clinic
		)
		m.oldValue = func(ctx context.Context) (*Clinic, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Clinic.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClinic sets the old Clinic of the mutation.
func withClinic(node *Clinic) clinicOption {
	return func(m *ClinicMutation) {
		m.oldValue = func(context.Context) (*Clinic, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClinicMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClinicMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Clinic creation.
func (m *ClinicMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ClinicMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *ClinicMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *ClinicMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Clinic.
// If the Clinic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClinicMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *ClinicMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *ClinicMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *ClinicMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Clinic.
// If the Clinic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClinicMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *ClinicMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRemovedAt sets the removed_at field.
func (m *ClinicMutation) SetRemovedAt(t time.Time) {
	m.removed_at = &t
}

// RemovedAt returns the removed_at value in the mutation.
func (m *ClinicMutation) RemovedAt() (r time.Time, exists bool) {
	v := m.removed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRemovedAt returns the old removed_at value of the Clinic.
// If the Clinic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClinicMutation) OldRemovedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemovedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemovedAt: %w", err)
	}
	return oldValue.RemovedAt, nil
}

// ClearRemovedAt clears the value of removed_at.
func (m *ClinicMutation) ClearRemovedAt() {
	m.removed_at = nil
	m.clearedFields[clinic.FieldRemovedAt] = struct{}{}
}

// RemovedAtCleared returns if the field removed_at was cleared in this mutation.
func (m *ClinicMutation) RemovedAtCleared() bool {
	_, ok := m.clearedFields[clinic.FieldRemovedAt]
	return ok
}

// ResetRemovedAt reset all changes of the "removed_at" field.
func (m *ClinicMutation) ResetRemovedAt() {
	m.removed_at = nil
	delete(m.clearedFields, clinic.FieldRemovedAt)
}

// SetName sets the name field.
func (m *ClinicMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ClinicMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Clinic.
// If the Clinic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClinicMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ClinicMutation) ResetName() {
	m.name = nil
}

// SetAddress sets the address field.
func (m *ClinicMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the address value in the mutation.
func (m *ClinicMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old address value of the Clinic.
// If the Clinic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClinicMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddress is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress reset all changes of the "address" field.
func (m *ClinicMutation) ResetAddress() {
	m.address = nil
}

// SetPhone sets the phone field.
func (m *ClinicMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the phone value in the mutation.
func (m *ClinicMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old phone value of the Clinic.
// If the Clinic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClinicMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone reset all changes of the "phone" field.
func (m *ClinicMutation) ResetPhone() {
	m.phone = nil
}

// SetWebURL sets the web_url field.
func (m *ClinicMutation) SetWebURL(s string) {
	m.web_url = &s
}

// WebURL returns the web_url value in the mutation.
func (m *ClinicMutation) WebURL() (r string, exists bool) {
	v := m.web_url
	if v == nil {
		return
	}
	return *v, true
}

// OldWebURL returns the old web_url value of the Clinic.
// If the Clinic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ClinicMutation) OldWebURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWebURL is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWebURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebURL: %w", err)
	}
	return oldValue.WebURL, nil
}

// ResetWebURL reset all changes of the "web_url" field.
func (m *ClinicMutation) ResetWebURL() {
	m.web_url = nil
}

// AddVeterinarianIDs adds the veterinarians edge to Veterinarian by ids.
func (m *ClinicMutation) AddVeterinarianIDs(ids ...uuid.UUID) {
	if m.veterinarians == nil {
		m.veterinarians = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.veterinarians[ids[i]] = struct{}{}
	}
}

// ClearVeterinarians clears the veterinarians edge to Veterinarian.
func (m *ClinicMutation) ClearVeterinarians() {
	m.clearedveterinarians = true
}

// VeterinariansCleared returns if the edge veterinarians was cleared.
func (m *ClinicMutation) VeterinariansCleared() bool {
	return m.clearedveterinarians
}

// RemoveVeterinarianIDs removes the veterinarians edge to Veterinarian by ids.
func (m *ClinicMutation) RemoveVeterinarianIDs(ids ...uuid.UUID) {
	if m.removedveterinarians == nil {
		m.removedveterinarians = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removedveterinarians[ids[i]] = struct{}{}
	}
}

// RemovedVeterinarians returns the removed ids of veterinarians.
func (m *ClinicMutation) RemovedVeterinariansIDs() (ids []uuid.UUID) {
	for id := range m.removedveterinarians {
		ids = append(ids, id)
	}
	return
}

// VeterinariansIDs returns the veterinarians ids in the mutation.
func (m *ClinicMutation) VeterinariansIDs() (ids []uuid.UUID) {
	for id := range m.veterinarians {
		ids = append(ids, id)
	}
	return
}

// ResetVeterinarians reset all changes of the "veterinarians" edge.
func (m *ClinicMutation) ResetVeterinarians() {
	m.veterinarians = nil
	m.clearedveterinarians = false
	m.removedveterinarians = nil
}

// Op returns the operation name.
func (m *ClinicMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Clinic).
func (m *ClinicMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ClinicMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, clinic.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, clinic.FieldUpdatedAt)
	}
	if m.removed_at != nil {
		fields = append(fields, clinic.FieldRemovedAt)
	}
	if m.name != nil {
		fields = append(fields, clinic.FieldName)
	}
	if m.address != nil {
		fields = append(fields, clinic.FieldAddress)
	}
	if m.phone != nil {
		fields = append(fields, clinic.FieldPhone)
	}
	if m.web_url != nil {
		fields = append(fields, clinic.FieldWebURL)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ClinicMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case clinic.FieldCreatedAt:
		return m.CreatedAt()
	case clinic.FieldUpdatedAt:
		return m.UpdatedAt()
	case clinic.FieldRemovedAt:
		return m.RemovedAt()
	case clinic.FieldName:
		return m.Name()
	case clinic.FieldAddress:
		return m.Address()
	case clinic.FieldPhone:
		return m.Phone()
	case clinic.FieldWebURL:
		return m.WebURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ClinicMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case clinic.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case clinic.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case clinic.FieldRemovedAt:
		return m.OldRemovedAt(ctx)
	case clinic.FieldName:
		return m.OldName(ctx)
	case clinic.FieldAddress:
		return m.OldAddress(ctx)
	case clinic.FieldPhone:
		return m.OldPhone(ctx)
	case clinic.FieldWebURL:
		return m.OldWebURL(ctx)
	}
	return nil, fmt.Errorf("unknown Clinic field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClinicMutation) SetField(name string, value ent.Value) error {
	switch name {
	case clinic.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case clinic.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case clinic.FieldRemovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemovedAt(v)
		return nil
	case clinic.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case clinic.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case clinic.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case clinic.FieldWebURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebURL(v)
		return nil
	}
	return fmt.Errorf("unknown Clinic field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ClinicMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ClinicMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ClinicMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Clinic numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ClinicMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(clinic.FieldRemovedAt) {
		fields = append(fields, clinic.FieldRemovedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ClinicMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClinicMutation) ClearField(name string) error {
	switch name {
	case clinic.FieldRemovedAt:
		m.ClearRemovedAt()
		return nil
	}
	return fmt.Errorf("unknown Clinic nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ClinicMutation) ResetField(name string) error {
	switch name {
	case clinic.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case clinic.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case clinic.FieldRemovedAt:
		m.ResetRemovedAt()
		return nil
	case clinic.FieldName:
		m.ResetName()
		return nil
	case clinic.FieldAddress:
		m.ResetAddress()
		return nil
	case clinic.FieldPhone:
		m.ResetPhone()
		return nil
	case clinic.FieldWebURL:
		m.ResetWebURL()
		return nil
	}
	return fmt.Errorf("unknown Clinic field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ClinicMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.veterinarians != nil {
		edges = append(edges, clinic.EdgeVeterinarians)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ClinicMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case clinic.EdgeVeterinarians:
		ids := make([]ent.Value, 0, len(m.veterinarians))
		for id := range m.veterinarians {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ClinicMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedveterinarians != nil {
		edges = append(edges, clinic.EdgeVeterinarians)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ClinicMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case clinic.EdgeVeterinarians:
		ids := make([]ent.Value, 0, len(m.removedveterinarians))
		for id := range m.removedveterinarians {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ClinicMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedveterinarians {
		edges = append(edges, clinic.EdgeVeterinarians)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ClinicMutation) EdgeCleared(name string) bool {
	switch name {
	case clinic.EdgeVeterinarians:
		return m.clearedveterinarians
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ClinicMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Clinic unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ClinicMutation) ResetEdge(name string) error {
	switch name {
	case clinic.EdgeVeterinarians:
		m.ResetVeterinarians()
		return nil
	}
	return fmt.Errorf("unknown Clinic edge %s", name)
}

// CustomerMutation represents an operation that mutate the Customers
// nodes in the graph.
type CustomerMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	removed_at    *time.Time
	address       *string
	phone         *string
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	pets          map[uuid.UUID]struct{}
	removedpets   map[uuid.UUID]struct{}
	clearedpets   bool
	done          bool
	oldValue      func(context.Context) (*Customer, error)
	predicates    []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows to manage the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for $n.Name.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the id field of the mutation.
func withCustomerID(id uuid.UUID) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Customer creation.
func (m *CustomerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CustomerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *CustomerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *CustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *CustomerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *CustomerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *CustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *CustomerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRemovedAt sets the removed_at field.
func (m *CustomerMutation) SetRemovedAt(t time.Time) {
	m.removed_at = &t
}

// RemovedAt returns the removed_at value in the mutation.
func (m *CustomerMutation) RemovedAt() (r time.Time, exists bool) {
	v := m.removed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRemovedAt returns the old removed_at value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldRemovedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemovedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemovedAt: %w", err)
	}
	return oldValue.RemovedAt, nil
}

// ClearRemovedAt clears the value of removed_at.
func (m *CustomerMutation) ClearRemovedAt() {
	m.removed_at = nil
	m.clearedFields[customer.FieldRemovedAt] = struct{}{}
}

// RemovedAtCleared returns if the field removed_at was cleared in this mutation.
func (m *CustomerMutation) RemovedAtCleared() bool {
	_, ok := m.clearedFields[customer.FieldRemovedAt]
	return ok
}

// ResetRemovedAt reset all changes of the "removed_at" field.
func (m *CustomerMutation) ResetRemovedAt() {
	m.removed_at = nil
	delete(m.clearedFields, customer.FieldRemovedAt)
}

// SetAddress sets the address field.
func (m *CustomerMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the address value in the mutation.
func (m *CustomerMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old address value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddress is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress reset all changes of the "address" field.
func (m *CustomerMutation) ResetAddress() {
	m.address = nil
}

// SetPhone sets the phone field.
func (m *CustomerMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the phone value in the mutation.
func (m *CustomerMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old phone value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone reset all changes of the "phone" field.
func (m *CustomerMutation) ResetPhone() {
	m.phone = nil
}

// SetUserID sets the user edge to User by id.
func (m *CustomerMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *CustomerMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *CustomerMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *CustomerMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *CustomerMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddPetIDs adds the pets edge to Pet by ids.
func (m *CustomerMutation) AddPetIDs(ids ...uuid.UUID) {
	if m.pets == nil {
		m.pets = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.pets[ids[i]] = struct{}{}
	}
}

// ClearPets clears the pets edge to Pet.
func (m *CustomerMutation) ClearPets() {
	m.clearedpets = true
}

// PetsCleared returns if the edge pets was cleared.
func (m *CustomerMutation) PetsCleared() bool {
	return m.clearedpets
}

// RemovePetIDs removes the pets edge to Pet by ids.
func (m *CustomerMutation) RemovePetIDs(ids ...uuid.UUID) {
	if m.removedpets == nil {
		m.removedpets = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removedpets[ids[i]] = struct{}{}
	}
}

// RemovedPets returns the removed ids of pets.
func (m *CustomerMutation) RemovedPetsIDs() (ids []uuid.UUID) {
	for id := range m.removedpets {
		ids = append(ids, id)
	}
	return
}

// PetsIDs returns the pets ids in the mutation.
func (m *CustomerMutation) PetsIDs() (ids []uuid.UUID) {
	for id := range m.pets {
		ids = append(ids, id)
	}
	return
}

// ResetPets reset all changes of the "pets" edge.
func (m *CustomerMutation) ResetPets() {
	m.pets = nil
	m.clearedpets = false
	m.removedpets = nil
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, customer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customer.FieldUpdatedAt)
	}
	if m.removed_at != nil {
		fields = append(fields, customer.FieldRemovedAt)
	}
	if m.address != nil {
		fields = append(fields, customer.FieldAddress)
	}
	if m.phone != nil {
		fields = append(fields, customer.FieldPhone)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldCreatedAt:
		return m.CreatedAt()
	case customer.FieldUpdatedAt:
		return m.UpdatedAt()
	case customer.FieldRemovedAt:
		return m.RemovedAt()
	case customer.FieldAddress:
		return m.Address()
	case customer.FieldPhone:
		return m.Phone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customer.FieldRemovedAt:
		return m.OldRemovedAt(ctx)
	case customer.FieldAddress:
		return m.OldAddress(ctx)
	case customer.FieldPhone:
		return m.OldPhone(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customer.FieldRemovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemovedAt(v)
		return nil
	case customer.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case customer.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customer.FieldRemovedAt) {
		fields = append(fields, customer.FieldRemovedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	switch name {
	case customer.FieldRemovedAt:
		m.ClearRemovedAt()
		return nil
	}
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customer.FieldRemovedAt:
		m.ResetRemovedAt()
		return nil
	case customer.FieldAddress:
		m.ResetAddress()
		return nil
	case customer.FieldPhone:
		m.ResetPhone()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, customer.EdgeUser)
	}
	if m.pets != nil {
		edges = append(edges, customer.EdgePets)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgePets:
		ids := make([]ent.Value, 0, len(m.pets))
		for id := range m.pets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpets != nil {
		edges = append(edges, customer.EdgePets)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgePets:
		ids := make([]ent.Value, 0, len(m.removedpets))
		for id := range m.removedpets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, customer.EdgeUser)
	}
	if m.clearedpets {
		edges = append(edges, customer.EdgePets)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case customer.EdgeUser:
		return m.cleareduser
	case customer.EdgePets:
		return m.clearedpets
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	case customer.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeUser:
		m.ResetUser()
		return nil
	case customer.EdgePets:
		m.ResetPets()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// PetMutation represents an operation that mutate the Pets
// nodes in the graph.
type PetMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	removed_at          *time.Time
	name                *string
	species             *pet.Species
	birth_date          *time.Time
	details             *string
	clearedFields       map[string]struct{}
	owner               *uuid.UUID
	clearedowner        bool
	appointments        map[uuid.UUID]struct{}
	removedappointments map[uuid.UUID]struct{}
	clearedappointments bool
	done                bool
	oldValue            func(context.Context) (*Pet, error)
	predicates          []predicate.Pet
}

var _ ent.Mutation = (*PetMutation)(nil)

// petOption allows to manage the mutation configuration using functional options.
type petOption func(*PetMutation)

// newPetMutation creates new mutation for $n.Name.
func newPetMutation(c config, op Op, opts ...petOption) *PetMutation {
	m := &PetMutation{
		config:        c,
		op:            op,
		typ:           TypePet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPetID sets the id field of the mutation.
func withPetID(id uuid.UUID) petOption {
	return func(m *PetMutation) {
		var (
			err   error
			once  sync.Once
			value *Pet
		)
		m.oldValue = func(ctx context.Context) (*Pet, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPet sets the old Pet of the mutation.
func withPet(node *Pet) petOption {
	return func(m *PetMutation) {
		m.oldValue = func(context.Context) (*Pet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Pet creation.
func (m *PetMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PetMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *PetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *PetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Pet.
// If the Pet object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *PetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *PetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *PetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Pet.
// If the Pet object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *PetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRemovedAt sets the removed_at field.
func (m *PetMutation) SetRemovedAt(t time.Time) {
	m.removed_at = &t
}

// RemovedAt returns the removed_at value in the mutation.
func (m *PetMutation) RemovedAt() (r time.Time, exists bool) {
	v := m.removed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRemovedAt returns the old removed_at value of the Pet.
// If the Pet object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PetMutation) OldRemovedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemovedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemovedAt: %w", err)
	}
	return oldValue.RemovedAt, nil
}

// ClearRemovedAt clears the value of removed_at.
func (m *PetMutation) ClearRemovedAt() {
	m.removed_at = nil
	m.clearedFields[pet.FieldRemovedAt] = struct{}{}
}

// RemovedAtCleared returns if the field removed_at was cleared in this mutation.
func (m *PetMutation) RemovedAtCleared() bool {
	_, ok := m.clearedFields[pet.FieldRemovedAt]
	return ok
}

// ResetRemovedAt reset all changes of the "removed_at" field.
func (m *PetMutation) ResetRemovedAt() {
	m.removed_at = nil
	delete(m.clearedFields, pet.FieldRemovedAt)
}

// SetName sets the name field.
func (m *PetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *PetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Pet.
// If the Pet object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *PetMutation) ResetName() {
	m.name = nil
}

// SetSpecies sets the species field.
func (m *PetMutation) SetSpecies(pe pet.Species) {
	m.species = &pe
}

// Species returns the species value in the mutation.
func (m *PetMutation) Species() (r pet.Species, exists bool) {
	v := m.species
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecies returns the old species value of the Pet.
// If the Pet object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PetMutation) OldSpecies(ctx context.Context) (v pet.Species, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpecies is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpecies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecies: %w", err)
	}
	return oldValue.Species, nil
}

// ResetSpecies reset all changes of the "species" field.
func (m *PetMutation) ResetSpecies() {
	m.species = nil
}

// SetBirthDate sets the birth_date field.
func (m *PetMutation) SetBirthDate(t time.Time) {
	m.birth_date = &t
}

// BirthDate returns the birth_date value in the mutation.
func (m *PetMutation) BirthDate() (r time.Time, exists bool) {
	v := m.birth_date
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthDate returns the old birth_date value of the Pet.
// If the Pet object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PetMutation) OldBirthDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBirthDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBirthDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthDate: %w", err)
	}
	return oldValue.BirthDate, nil
}

// ClearBirthDate clears the value of birth_date.
func (m *PetMutation) ClearBirthDate() {
	m.birth_date = nil
	m.clearedFields[pet.FieldBirthDate] = struct{}{}
}

// BirthDateCleared returns if the field birth_date was cleared in this mutation.
func (m *PetMutation) BirthDateCleared() bool {
	_, ok := m.clearedFields[pet.FieldBirthDate]
	return ok
}

// ResetBirthDate reset all changes of the "birth_date" field.
func (m *PetMutation) ResetBirthDate() {
	m.birth_date = nil
	delete(m.clearedFields, pet.FieldBirthDate)
}

// SetDetails sets the details field.
func (m *PetMutation) SetDetails(s string) {
	m.details = &s
}

// Details returns the details value in the mutation.
func (m *PetMutation) Details() (r string, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old details value of the Pet.
// If the Pet object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PetMutation) OldDetails(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDetails is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of details.
func (m *PetMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[pet.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the field details was cleared in this mutation.
func (m *PetMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[pet.FieldDetails]
	return ok
}

// ResetDetails reset all changes of the "details" field.
func (m *PetMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, pet.FieldDetails)
}

// SetOwnerID sets the owner edge to Customer by id.
func (m *PetMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the owner edge to Customer.
func (m *PetMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared returns if the edge owner was cleared.
func (m *PetMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the owner id in the mutation.
func (m *PetMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the owner ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *PetMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner reset all changes of the "owner" edge.
func (m *PetMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddAppointmentIDs adds the appointments edge to Appointment by ids.
func (m *PetMutation) AddAppointmentIDs(ids ...uuid.UUID) {
	if m.appointments == nil {
		m.appointments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.appointments[ids[i]] = struct{}{}
	}
}

// ClearAppointments clears the appointments edge to Appointment.
func (m *PetMutation) ClearAppointments() {
	m.clearedappointments = true
}

// AppointmentsCleared returns if the edge appointments was cleared.
func (m *PetMutation) AppointmentsCleared() bool {
	return m.clearedappointments
}

// RemoveAppointmentIDs removes the appointments edge to Appointment by ids.
func (m *PetMutation) RemoveAppointmentIDs(ids ...uuid.UUID) {
	if m.removedappointments == nil {
		m.removedappointments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removedappointments[ids[i]] = struct{}{}
	}
}

// RemovedAppointments returns the removed ids of appointments.
func (m *PetMutation) RemovedAppointmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedappointments {
		ids = append(ids, id)
	}
	return
}

// AppointmentsIDs returns the appointments ids in the mutation.
func (m *PetMutation) AppointmentsIDs() (ids []uuid.UUID) {
	for id := range m.appointments {
		ids = append(ids, id)
	}
	return
}

// ResetAppointments reset all changes of the "appointments" edge.
func (m *PetMutation) ResetAppointments() {
	m.appointments = nil
	m.clearedappointments = false
	m.removedappointments = nil
}

// Op returns the operation name.
func (m *PetMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Pet).
func (m *PetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PetMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, pet.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pet.FieldUpdatedAt)
	}
	if m.removed_at != nil {
		fields = append(fields, pet.FieldRemovedAt)
	}
	if m.name != nil {
		fields = append(fields, pet.FieldName)
	}
	if m.species != nil {
		fields = append(fields, pet.FieldSpecies)
	}
	if m.birth_date != nil {
		fields = append(fields, pet.FieldBirthDate)
	}
	if m.details != nil {
		fields = append(fields, pet.FieldDetails)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pet.FieldCreatedAt:
		return m.CreatedAt()
	case pet.FieldUpdatedAt:
		return m.UpdatedAt()
	case pet.FieldRemovedAt:
		return m.RemovedAt()
	case pet.FieldName:
		return m.Name()
	case pet.FieldSpecies:
		return m.Species()
	case pet.FieldBirthDate:
		return m.BirthDate()
	case pet.FieldDetails:
		return m.Details()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pet.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pet.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pet.FieldRemovedAt:
		return m.OldRemovedAt(ctx)
	case pet.FieldName:
		return m.OldName(ctx)
	case pet.FieldSpecies:
		return m.OldSpecies(ctx)
	case pet.FieldBirthDate:
		return m.OldBirthDate(ctx)
	case pet.FieldDetails:
		return m.OldDetails(ctx)
	}
	return nil, fmt.Errorf("unknown Pet field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pet.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pet.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pet.FieldRemovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemovedAt(v)
		return nil
	case pet.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case pet.FieldSpecies:
		v, ok := value.(pet.Species)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecies(v)
		return nil
	case pet.FieldBirthDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthDate(v)
		return nil
	case pet.FieldDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	}
	return fmt.Errorf("unknown Pet field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Pet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pet.FieldRemovedAt) {
		fields = append(fields, pet.FieldRemovedAt)
	}
	if m.FieldCleared(pet.FieldBirthDate) {
		fields = append(fields, pet.FieldBirthDate)
	}
	if m.FieldCleared(pet.FieldDetails) {
		fields = append(fields, pet.FieldDetails)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PetMutation) ClearField(name string) error {
	switch name {
	case pet.FieldRemovedAt:
		m.ClearRemovedAt()
		return nil
	case pet.FieldBirthDate:
		m.ClearBirthDate()
		return nil
	case pet.FieldDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown Pet nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PetMutation) ResetField(name string) error {
	switch name {
	case pet.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pet.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pet.FieldRemovedAt:
		m.ResetRemovedAt()
		return nil
	case pet.FieldName:
		m.ResetName()
		return nil
	case pet.FieldSpecies:
		m.ResetSpecies()
		return nil
	case pet.FieldBirthDate:
		m.ResetBirthDate()
		return nil
	case pet.FieldDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown Pet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PetMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, pet.EdgeOwner)
	}
	if m.appointments != nil {
		edges = append(edges, pet.EdgeAppointments)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pet.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case pet.EdgeAppointments:
		ids := make([]ent.Value, 0, len(m.appointments))
		for id := range m.appointments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedappointments != nil {
		edges = append(edges, pet.EdgeAppointments)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case pet.EdgeAppointments:
		ids := make([]ent.Value, 0, len(m.removedappointments))
		for id := range m.removedappointments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, pet.EdgeOwner)
	}
	if m.clearedappointments {
		edges = append(edges, pet.EdgeAppointments)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PetMutation) EdgeCleared(name string) bool {
	switch name {
	case pet.EdgeOwner:
		return m.clearedowner
	case pet.EdgeAppointments:
		return m.clearedappointments
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PetMutation) ClearEdge(name string) error {
	switch name {
	case pet.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Pet unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PetMutation) ResetEdge(name string) error {
	switch name {
	case pet.EdgeOwner:
		m.ResetOwner()
		return nil
	case pet.EdgeAppointments:
		m.ResetAppointments()
		return nil
	}
	return fmt.Errorf("unknown Pet edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	removed_at          *time.Time
	email               *string
	first_name          *string
	last_name           *string
	clearedFields       map[string]struct{}
	veterinarian        *uuid.UUID
	clearedveterinarian bool
	customer            *uuid.UUID
	clearedcustomer     bool
	done                bool
	oldValue            func(context.Context) (*User, error)
	predicates          []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on User creation.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRemovedAt sets the removed_at field.
func (m *UserMutation) SetRemovedAt(t time.Time) {
	m.removed_at = &t
}

// RemovedAt returns the removed_at value in the mutation.
func (m *UserMutation) RemovedAt() (r time.Time, exists bool) {
	v := m.removed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRemovedAt returns the old removed_at value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldRemovedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemovedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemovedAt: %w", err)
	}
	return oldValue.RemovedAt, nil
}

// ClearRemovedAt clears the value of removed_at.
func (m *UserMutation) ClearRemovedAt() {
	m.removed_at = nil
	m.clearedFields[user.FieldRemovedAt] = struct{}{}
}

// RemovedAtCleared returns if the field removed_at was cleared in this mutation.
func (m *UserMutation) RemovedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldRemovedAt]
	return ok
}

// ResetRemovedAt reset all changes of the "removed_at" field.
func (m *UserMutation) ResetRemovedAt() {
	m.removed_at = nil
	delete(m.clearedFields, user.FieldRemovedAt)
}

// SetEmail sets the email field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetFirstName sets the first_name field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the first_name value in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old first_name value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName reset all changes of the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the last_name field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the last_name value in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old last_name value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName reset all changes of the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
}

// SetVeterinarianID sets the veterinarian edge to Veterinarian by id.
func (m *UserMutation) SetVeterinarianID(id uuid.UUID) {
	m.veterinarian = &id
}

// ClearVeterinarian clears the veterinarian edge to Veterinarian.
func (m *UserMutation) ClearVeterinarian() {
	m.clearedveterinarian = true
}

// VeterinarianCleared returns if the edge veterinarian was cleared.
func (m *UserMutation) VeterinarianCleared() bool {
	return m.clearedveterinarian
}

// VeterinarianID returns the veterinarian id in the mutation.
func (m *UserMutation) VeterinarianID() (id uuid.UUID, exists bool) {
	if m.veterinarian != nil {
		return *m.veterinarian, true
	}
	return
}

// VeterinarianIDs returns the veterinarian ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// VeterinarianID instead. It exists only for internal usage by the builders.
func (m *UserMutation) VeterinarianIDs() (ids []uuid.UUID) {
	if id := m.veterinarian; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVeterinarian reset all changes of the "veterinarian" edge.
func (m *UserMutation) ResetVeterinarian() {
	m.veterinarian = nil
	m.clearedveterinarian = false
}

// SetCustomerID sets the customer edge to Customer by id.
func (m *UserMutation) SetCustomerID(id uuid.UUID) {
	m.customer = &id
}

// ClearCustomer clears the customer edge to Customer.
func (m *UserMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared returns if the edge customer was cleared.
func (m *UserMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerID returns the customer id in the mutation.
func (m *UserMutation) CustomerID() (id uuid.UUID, exists bool) {
	if m.customer != nil {
		return *m.customer, true
	}
	return
}

// CustomerIDs returns the customer ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CustomerIDs() (ids []uuid.UUID) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer reset all changes of the "customer" edge.
func (m *UserMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.removed_at != nil {
		fields = append(fields, user.FieldRemovedAt)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldRemovedAt:
		return m.RemovedAt()
	case user.FieldEmail:
		return m.Email()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldRemovedAt:
		return m.OldRemovedAt(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldRemovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemovedAt(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldRemovedAt) {
		fields = append(fields, user.FieldRemovedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldRemovedAt:
		m.ClearRemovedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldRemovedAt:
		m.ResetRemovedAt()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.veterinarian != nil {
		edges = append(edges, user.EdgeVeterinarian)
	}
	if m.customer != nil {
		edges = append(edges, user.EdgeCustomer)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeVeterinarian:
		if id := m.veterinarian; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedveterinarian {
		edges = append(edges, user.EdgeVeterinarian)
	}
	if m.clearedcustomer {
		edges = append(edges, user.EdgeCustomer)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeVeterinarian:
		return m.clearedveterinarian
	case user.EdgeCustomer:
		return m.clearedcustomer
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeVeterinarian:
		m.ClearVeterinarian()
		return nil
	case user.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeVeterinarian:
		m.ResetVeterinarian()
		return nil
	case user.EdgeCustomer:
		m.ResetCustomer()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VeterinarianMutation represents an operation that mutate the Veterinarians
// nodes in the graph.
type VeterinarianMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	removed_at          *time.Time
	phone               *string
	clearedFields       map[string]struct{}
	user                *uuid.UUID
	cleareduser         bool
	clinic              *uuid.UUID
	clearedclinic       bool
	appointments        map[uuid.UUID]struct{}
	removedappointments map[uuid.UUID]struct{}
	clearedappointments bool
	done                bool
	oldValue            func(context.Context) (*Veterinarian, error)
	predicates          []predicate.Veterinarian
}

var _ ent.Mutation = (*VeterinarianMutation)(nil)

// veterinarianOption allows to manage the mutation configuration using functional options.
type veterinarianOption func(*VeterinarianMutation)

// newVeterinarianMutation creates new mutation for $n.Name.
func newVeterinarianMutation(c config, op Op, opts ...veterinarianOption) *VeterinarianMutation {
	m := &VeterinarianMutation{
		config:        c,
		op:            op,
		typ:           TypeVeterinarian,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVeterinarianID sets the id field of the mutation.
func withVeterinarianID(id uuid.UUID) veterinarianOption {
	return func(m *VeterinarianMutation) {
		var (
			err   error
			once  sync.Once
			value *Veterinarian
		)
		m.oldValue = func(ctx context.Context) (*Veterinarian, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Veterinarian.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVeterinarian sets the old Veterinarian of the mutation.
func withVeterinarian(node *Veterinarian) veterinarianOption {
	return func(m *VeterinarianMutation) {
		m.oldValue = func(context.Context) (*Veterinarian, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VeterinarianMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VeterinarianMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on Veterinarian creation.
func (m *VeterinarianMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *VeterinarianMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the created_at field.
func (m *VeterinarianMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *VeterinarianMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Veterinarian.
// If the Veterinarian object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *VeterinarianMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *VeterinarianMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *VeterinarianMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *VeterinarianMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Veterinarian.
// If the Veterinarian object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *VeterinarianMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *VeterinarianMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRemovedAt sets the removed_at field.
func (m *VeterinarianMutation) SetRemovedAt(t time.Time) {
	m.removed_at = &t
}

// RemovedAt returns the removed_at value in the mutation.
func (m *VeterinarianMutation) RemovedAt() (r time.Time, exists bool) {
	v := m.removed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRemovedAt returns the old removed_at value of the Veterinarian.
// If the Veterinarian object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *VeterinarianMutation) OldRemovedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemovedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemovedAt: %w", err)
	}
	return oldValue.RemovedAt, nil
}

// ClearRemovedAt clears the value of removed_at.
func (m *VeterinarianMutation) ClearRemovedAt() {
	m.removed_at = nil
	m.clearedFields[veterinarian.FieldRemovedAt] = struct{}{}
}

// RemovedAtCleared returns if the field removed_at was cleared in this mutation.
func (m *VeterinarianMutation) RemovedAtCleared() bool {
	_, ok := m.clearedFields[veterinarian.FieldRemovedAt]
	return ok
}

// ResetRemovedAt reset all changes of the "removed_at" field.
func (m *VeterinarianMutation) ResetRemovedAt() {
	m.removed_at = nil
	delete(m.clearedFields, veterinarian.FieldRemovedAt)
}

// SetPhone sets the phone field.
func (m *VeterinarianMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the phone value in the mutation.
func (m *VeterinarianMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old phone value of the Veterinarian.
// If the Veterinarian object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *VeterinarianMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone reset all changes of the "phone" field.
func (m *VeterinarianMutation) ResetPhone() {
	m.phone = nil
}

// SetUserID sets the user edge to User by id.
func (m *VeterinarianMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *VeterinarianMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *VeterinarianMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *VeterinarianMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *VeterinarianMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *VeterinarianMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetClinicID sets the clinic edge to Clinic by id.
func (m *VeterinarianMutation) SetClinicID(id uuid.UUID) {
	m.clinic = &id
}

// ClearClinic clears the clinic edge to Clinic.
func (m *VeterinarianMutation) ClearClinic() {
	m.clearedclinic = true
}

// ClinicCleared returns if the edge clinic was cleared.
func (m *VeterinarianMutation) ClinicCleared() bool {
	return m.clearedclinic
}

// ClinicID returns the clinic id in the mutation.
func (m *VeterinarianMutation) ClinicID() (id uuid.UUID, exists bool) {
	if m.clinic != nil {
		return *m.clinic, true
	}
	return
}

// ClinicIDs returns the clinic ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ClinicID instead. It exists only for internal usage by the builders.
func (m *VeterinarianMutation) ClinicIDs() (ids []uuid.UUID) {
	if id := m.clinic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClinic reset all changes of the "clinic" edge.
func (m *VeterinarianMutation) ResetClinic() {
	m.clinic = nil
	m.clearedclinic = false
}

// AddAppointmentIDs adds the appointments edge to Appointment by ids.
func (m *VeterinarianMutation) AddAppointmentIDs(ids ...uuid.UUID) {
	if m.appointments == nil {
		m.appointments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.appointments[ids[i]] = struct{}{}
	}
}

// ClearAppointments clears the appointments edge to Appointment.
func (m *VeterinarianMutation) ClearAppointments() {
	m.clearedappointments = true
}

// AppointmentsCleared returns if the edge appointments was cleared.
func (m *VeterinarianMutation) AppointmentsCleared() bool {
	return m.clearedappointments
}

// RemoveAppointmentIDs removes the appointments edge to Appointment by ids.
func (m *VeterinarianMutation) RemoveAppointmentIDs(ids ...uuid.UUID) {
	if m.removedappointments == nil {
		m.removedappointments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removedappointments[ids[i]] = struct{}{}
	}
}

// RemovedAppointments returns the removed ids of appointments.
func (m *VeterinarianMutation) RemovedAppointmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedappointments {
		ids = append(ids, id)
	}
	return
}

// AppointmentsIDs returns the appointments ids in the mutation.
func (m *VeterinarianMutation) AppointmentsIDs() (ids []uuid.UUID) {
	for id := range m.appointments {
		ids = append(ids, id)
	}
	return
}

// ResetAppointments reset all changes of the "appointments" edge.
func (m *VeterinarianMutation) ResetAppointments() {
	m.appointments = nil
	m.clearedappointments = false
	m.removedappointments = nil
}

// Op returns the operation name.
func (m *VeterinarianMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Veterinarian).
func (m *VeterinarianMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *VeterinarianMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, veterinarian.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, veterinarian.FieldUpdatedAt)
	}
	if m.removed_at != nil {
		fields = append(fields, veterinarian.FieldRemovedAt)
	}
	if m.phone != nil {
		fields = append(fields, veterinarian.FieldPhone)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *VeterinarianMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case veterinarian.FieldCreatedAt:
		return m.CreatedAt()
	case veterinarian.FieldUpdatedAt:
		return m.UpdatedAt()
	case veterinarian.FieldRemovedAt:
		return m.RemovedAt()
	case veterinarian.FieldPhone:
		return m.Phone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *VeterinarianMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case veterinarian.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case veterinarian.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case veterinarian.FieldRemovedAt:
		return m.OldRemovedAt(ctx)
	case veterinarian.FieldPhone:
		return m.OldPhone(ctx)
	}
	return nil, fmt.Errorf("unknown Veterinarian field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *VeterinarianMutation) SetField(name string, value ent.Value) error {
	switch name {
	case veterinarian.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case veterinarian.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case veterinarian.FieldRemovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemovedAt(v)
		return nil
	case veterinarian.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	}
	return fmt.Errorf("unknown Veterinarian field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *VeterinarianMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *VeterinarianMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *VeterinarianMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Veterinarian numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *VeterinarianMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(veterinarian.FieldRemovedAt) {
		fields = append(fields, veterinarian.FieldRemovedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *VeterinarianMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *VeterinarianMutation) ClearField(name string) error {
	switch name {
	case veterinarian.FieldRemovedAt:
		m.ClearRemovedAt()
		return nil
	}
	return fmt.Errorf("unknown Veterinarian nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *VeterinarianMutation) ResetField(name string) error {
	switch name {
	case veterinarian.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case veterinarian.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case veterinarian.FieldRemovedAt:
		m.ResetRemovedAt()
		return nil
	case veterinarian.FieldPhone:
		m.ResetPhone()
		return nil
	}
	return fmt.Errorf("unknown Veterinarian field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *VeterinarianMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, veterinarian.EdgeUser)
	}
	if m.clinic != nil {
		edges = append(edges, veterinarian.EdgeClinic)
	}
	if m.appointments != nil {
		edges = append(edges, veterinarian.EdgeAppointments)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *VeterinarianMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case veterinarian.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case veterinarian.EdgeClinic:
		if id := m.clinic; id != nil {
			return []ent.Value{*id}
		}
	case veterinarian.EdgeAppointments:
		ids := make([]ent.Value, 0, len(m.appointments))
		for id := range m.appointments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *VeterinarianMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedappointments != nil {
		edges = append(edges, veterinarian.EdgeAppointments)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *VeterinarianMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case veterinarian.EdgeAppointments:
		ids := make([]ent.Value, 0, len(m.removedappointments))
		for id := range m.removedappointments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *VeterinarianMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, veterinarian.EdgeUser)
	}
	if m.clearedclinic {
		edges = append(edges, veterinarian.EdgeClinic)
	}
	if m.clearedappointments {
		edges = append(edges, veterinarian.EdgeAppointments)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *VeterinarianMutation) EdgeCleared(name string) bool {
	switch name {
	case veterinarian.EdgeUser:
		return m.cleareduser
	case veterinarian.EdgeClinic:
		return m.clearedclinic
	case veterinarian.EdgeAppointments:
		return m.clearedappointments
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *VeterinarianMutation) ClearEdge(name string) error {
	switch name {
	case veterinarian.EdgeUser:
		m.ClearUser()
		return nil
	case veterinarian.EdgeClinic:
		m.ClearClinic()
		return nil
	}
	return fmt.Errorf("unknown Veterinarian unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *VeterinarianMutation) ResetEdge(name string) error {
	switch name {
	case veterinarian.EdgeUser:
		m.ResetUser()
		return nil
	case veterinarian.EdgeClinic:
		m.ResetClinic()
		return nil
	case veterinarian.EdgeAppointments:
		m.ResetAppointments()
		return nil
	}
	return fmt.Errorf("unknown Veterinarian edge %s", name)
}
